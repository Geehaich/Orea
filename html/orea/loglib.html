<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orea.loglib API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orea.loglib</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import datetime,timedelta
from enum import Enum

import yaml
import os
import psutil
from collections import deque,OrderedDict
from threading import Lock

from . import orea_core


class LogLevels(Enum) : #classic log levels for most applications
    FATAL = 0
    ERROR = 1
    WARN = 2
    INFO = 3
    DEBUG = 4
    TRACE = 5

DEFAULT_CRAWL_TIMEOUT = timedelta(seconds = 180)

class LogManagerWrapper :
    &#34;&#34;&#34;wrapper on LogManager rust struct providing convenience functions and type conversions to Rust compatible types.&#34;&#34;&#34;
    def __init__(self,fpath, deque_max_len = 20):
        &#34;&#34;&#34;ctor, initializes a LogManager object and a deque for entries.

        :param str fpath : tracked .yaml file
        :param int deque_max_len : size of the entry deque. default 20&#34;&#34;&#34;
        fpath = os.path.abspath(fpath)
        if not os.path.exists(fpath):
            open(fpath, &#39;w+&#39;).close()
        self._logmanager = orea_core.LogManager(fpath)
        self.file = open(fpath, &#39;a&#39;, encoding=&#34;utf-8&#34;)
        self.path = self._logmanager.file_name

        self.queue = deque(maxlen=deque_max_len)
        self.cursor_date = None #will stay None if empty file
        self.write_lock = Lock()
        self.read_lock = Lock() #deserialization

        self.pause= False

        last_entry = self.current_entry()
        if last_entry is not None :
            self.queue.append(last_entry)
            self.cursor_date = datetime.fromisoformat(last_entry.date)


        self.search_timeout = DEFAULT_CRAWL_TIMEOUT


    #slice_up/slice_down c
    def _scroll_up(self,n, header_cond_function = None, content_cond_function = None,inf_scroll = False) :
        &#34;&#34;&#34;collect documents from the current one going up in the bound file (previous entries) and appends them in the deque, optionally filtering them using a header and content
    #filtering function. moves the cursor up the file.

    :param func header_cond_function : filtering function with an access to every LogEntryField except the deserialized content
    :param func content_cond_function : filtering function also accounting for deserialized content
    :param bool inf_scroll : ignore search timeout. default : False&#34;&#34;&#34;
        result = 0
        if len(self.queue)!=0 and self.queue[0] is not None:
            self._logmanager.byte_jump( self.queue[0].total_extension[0] + self.queue[0].total_extension[1]//2) #set cursor position to earliest entry
        for i in range(n) :
            result = self.crawl_until(-1,header_cond_function,content_cond_function,inf_scroll)
        return result

    def _scroll_down(self, n, header_cond_function = None, content_cond_function = None,inf_scroll = False) :
        &#34;&#34;&#34;same as scroll_up in opposite direction&#34;&#34;&#34;
        result = 0
        if len(self.queue)!=0 and self.queue[-1] is not None:
            self._logmanager.byte_jump(self.queue[-1].total_extension[0] + self.queue[-1].total_extension[1] // 2)  # set cursor position to latest entry
        for i in range(n):
            result = self.crawl_until(1, header_cond_function, content_cond_function,inf_scroll)
        return result
    def scroll(self, n, header_cond_function = None, content_cond_function = None , inf_scroll = False) :
        &#34;&#34;&#34;calls scroll_up and scroll_down multiple time to move along the document.

        :param int n : amount of valid entries we go over.&#34;&#34;&#34;
        if n == 0:
            return None
        elif n &gt; 0 :
            counter = 0
            scroll_res = 0
            while counter &lt; n and scroll_res is not None :
                counter+=1
                scroll_res = self._scroll_down(1, header_cond_function, content_cond_function,inf_scroll)
            if scroll_res is None :
                return None
        else :
            counter = 0
            scroll_res = 0
            while counter &lt; -n and scroll_res is not None :
                counter+=1
                scroll_res = self._scroll_up(1, header_cond_function, content_cond_function,inf_scroll)
            if scroll_res is None :
                return None


    def crawl_until(self,direction : int, header_cond_function = None, content_cond_function = None, inf_scroll = False):
        &#34;&#34;&#34;moves along the file until an entry meets search criteria, stores it in the queue&#34;&#34;&#34;

        if header_cond_function is None and content_cond_function is None :
            if direction &lt; 0 :
                self.move(-1)
                ent = self.current_entry()
                if ent is not None :
                    if len(self.queue)!=0 and self.queue[0] is not None :

                        if not ent.total_extension[0]==self.queue[0].total_extension[0]==0 :
                            self.queue.appendleft(ent)
                else :
                    return None
            elif direction &gt; 0 :
                self.move(1)
                ent = self.current_entry()
                if ent is not None:
                    if len(self.queue) != 0 and  self.queue[-1] is not None :
                        if not ent.total_extension[0]==self.queue[-1].total_extension[0]:
                            self.queue.append(ent)
                else :
                    return None
            return 0

        increment = -1 if direction &lt;0 else 1

        if (inf_scroll == False) and (self.nothing_down_close and increment == 1) or (self.nothing_up_close and increment ==-1) :
            return

        entry = self.current_entry()
        cur_date = self.current_entry().date_obj()
        moved = 0
        while True :

            self.move(increment)
            moved +=1
            entry = self.current_entry()

            if entry is None : #either end of file, return None as stop condition for filling function
                return None


            stop_condition = True
            if content_cond_function is not None:
                stop_condition = stop_condition and content_cond_function(entry)
            if header_cond_function is not None :
                stop_condition = stop_condition and header_cond_function(entry)

            if inf_scroll == False and abs(entry.date_obj() - cur_date) &gt; self.search_timeout :
                if increment == 1:
                    self.nothing_down_close = True
                else :
                    self.nothing_up_close = True
                return -1


            extremal_condition = entry.total_extension[0]==0 or self.isateof()
                     #check if document is at either end of file

            if stop_condition : #condition met, add to queue
                break

            if extremal_condition : #end of file reached and condition not met, leave
                return None

        if increment  == -1 and entry is not None:
            if len(self.queue)==0 or (len(self.queue)!=0 and entry.total_extension[0]!=self.queue[0].total_extension[0]):
                self.queue.appendleft(entry)
                self.nothing_down_close = False #allows going back to previous entries
        if increment == 1 and entry is not None:
            if len(self.queue)==0 or entry.total_extension[0]!=self.queue[-1].total_extension[0]:
                self.queue.append(entry)
                self.nothing_up_close = False
        return moved

    def fill_queue(self,direction = -1, header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;fill entry queue in either direction using optional filtering functions&#34;&#34;&#34;
        increment = -1 if direction &lt; 0 else 1
        space_left = self.queue.maxlen -1 #keep the starting entry somewhere in queue

        if header_cond_function is None and content_cond_function is None :
            if direction &lt;0 :
                self.queue.clear()
                self.queue.append(self.current_entry())
                self._scroll_up(space_left)
            else :
                self.queue.clear()
                self.queue.append(self.current_entry())
                self._scroll_down(space_left)

        else :

            self.queue.clear()
            cur_ent = self.current_entry()
            if cur_ent is not None :
                current_fits = True
                if header_cond_function is not None :
                    current_fits = current_fits and header_cond_function(cur_ent.entry)
                if content_cond_function is not None :
                    current_fits = current_fits and content_cond_function(cur_ent)
                if current_fits :
                    self.queue.append(cur_ent)

            while space_left !=0 :

                res = self.crawl_until(direction,header_cond_function,content_cond_function)
                if res is None :
                    return
                else :
                    space_left -= 1


    def position_percent(self):
        &#34;&#34;&#34;returns the percentage of the current byte position to the total file length. &#34;&#34;&#34;
        return self._logmanager.current_doc_extend[0]/self._logmanager.file_byte_len()

    def isateof(self):
        &#34;&#34;&#34;compare current doc extension to file size to check if the cursor is at the end of the file&#34;&#34;&#34;
        return self._logmanager.file_byte_len() - (self._logmanager.current_doc_extend[0]+self._logmanager.current_doc_extend[1]) &lt; 10




    def search_date(self,date):
        &#34;&#34;&#34;moves to the entry with the specified date or the first one older than that. date should be a datetime object or an ISO date string &#34;&#34;&#34;

        self.nothing_up_close = False
        self.nothing_down_close = False

        if isinstance(date,datetime):
            self._logmanager.search_date(str(date))
        else :
            self._logmanager.search_date(date)

    def move(self,amount : int) :
        &#34;&#34;&#34;move along documents, direction specified by sign of amount.
        moving past the last or first document places the cursor back on the extremal document and return None, so does
        calling move on an empty file.
        &#34;&#34;&#34;

        if amount == 0 :
            return None

        self._logmanager.move_doc(amount)
        if self.current_entry() is not None :
            self.cursor_date = datetime.fromisoformat(self.current_entry().date)
        else : #case of empty file
            if self._logmanager.file_byte_len()&gt;0 and amount &gt; 0 :
                self.jump_last(refill=False)
            return None

    def get_content(self,entry : orea_core.LogEntryCore) -&gt; dict :
        &#34;&#34;&#34;get optional content from a LogEntryObject as a dict. You should favor using the deserialize method of a LogEntry to get contents, it will call this one on itself.&#34;&#34;&#34;
        text =self._logmanager.get_content(entry).replace(&#34;---\n&#34;,&#39;&#39;)
        return yaml.load(self._logmanager.get_content(entry),yaml.Loader)

    def date_interval(self,d1 :datetime.date ,d2 : datetime.date, cond_func = None):
        &#34;&#34;&#34;returns all entries between two date objects (or any object for which __repr__ returns an ISO formated date string,
        which also optionally meet a user defined criterium using a function of signature&#34;&#34;&#34;

        all_slice = self._logmanager.date_interval(str(d1),str(d2),None)
        if cond_func is None :
            return all_slice
        else :
            return [entry for entry in all_slice if cond_func(self,entry)==True]

    def current_entry(self):
        &#34;&#34;&#34;return the LogEntry the file cursor is currently pointing to&#34;&#34;&#34;
        core_ent = self._logmanager.current_entry()
        return LogEntry(self,core_ent) if core_ent is not None else None

    def current_core_entry(self):
        &#34;&#34;&#34;return the LogEntryCore the file cursor is currently pointing to&#34;&#34;&#34;
        return self._logmanager.current_entry()


    def jump_first(self,refill = True,header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;move to beginning of file.
        :param bool refill : if True, reset the entry deque
        :param header_cond_function : header filter function used if refilling
        :param content_cond_function :content filter&#34;&#34;&#34;
        self.nothing_up_close = False
        self.nothing_down_close = False

        self._logmanager.jump_first()
        first_ent = self.current_entry()
        if len(self.queue)!=0 and first_ent == self.queue[0]:
            return
        else :
            if refill :
                self.fill_queue(1,header_cond_function,content_cond_function)
            return len(self.queue)
        return 0


    def jump_last(self,refill=True,header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;Move to EoF, optional refill of deque&#34;&#34;&#34;

        self.nothing_up_close = False
        self.nothing_down_close = False

        self._logmanager.jump_last()
        last_ent = self.current_entry()
        if len(self.queue)!=0 and last_ent == self.queue[-1]:
            return
        else:
            if refill:
                self.fill_queue(-1, header_cond_function, content_cond_function)
            return len(self.queue)
        return 0

    def new_entry(self,message =&#34;&#34;, level=0, topic = &#34;&#34;, serialize_dict = None) :
        &#34;&#34;&#34;add new entry to the file the manager object is connected to.

        :param str message : entry message
        :param int level : entry log level. should be between 0-99
        :param str topic : entry topic, used for filtering later
        :param serialize_dict : oprional dictionary serialized as YAML and appended to the file along with the rest&#34;&#34;&#34;

        date = datetime.now()
        _level = level.value if isinstance(level, Enum) else level



        with self.write_lock:
            if not serialize_dict:  # print message directly without yaml dumping, saves a bit of performance
                self.file.seek(os.SEEK_END)
                self.file.write(
                    &#34;date: {}\nlevel: {}\ntopic: {}\nmessage: {}\n---\n&#34;.format(date, _level, topic, message))
                self.file.flush()
                return

            content_dict = {&#34;date&#34;:date,&#34;level&#34;:_level,&#34;topic&#34;:topic,&#34;message&#34;:message}
            content_dict.update(serialize_dict)
            content_str = yaml.dump(content_dict, sort_keys=False, allow_unicode=True)+&#39;---\n&#39;
            self.file.write(content_str)
            self.file.flush()


class LogEntry :
    &#34;&#34;&#34;
    wrapper around LogEntryCore to allow more ergonomic deserialization by keeping references to LogManagerWrapper objects

    :ivar log_man_ref: reference to the LogManagerWrapper which created the file
    :ivar entry: LogEntryCore defined in the rust API containing header info and byte extension
    :ivar extra: stores extra content after the function was called to avoid multiple costly deserializations&#34;&#34;&#34;

    def __init__(self,log_man:LogManagerWrapper,entry : orea_core.LogEntryCore):
        self.log_man_ref = log_man
        self.entry = entry
        self.extra = {} #store content in case of deserialization to avoid loading it several times

    def __getattr__(self, item):
        if item in [&#34;date&#34;,&#34;level&#34;,&#34;message&#34;,&#34;topic&#34;,&#34;dic_extension&#34;,&#34;total_extension&#34;]:
            return getattr(self.entry,item)
        elif item == &#34;log_man_ref&#34; :
            return self.log_man_ref
        elif item == &#34;entry&#34; :
            return self.entry
        else :
            raise KeyError(f&#34; &#39;Logentry&#39; object has no attribute {item}&#34;)

    def __repr__(self):
        return self.entry.__repr__()
    def deserialize(self):
        &#34;&#34;&#34;use deserialization function of LogManager. stores the result in the object to avoid loading it several times&#34;&#34;&#34;
        if self.dic_extension[1] == 0:
            return None
        else:

            if self.extra :
                return self.extra
            else :

                try :
                    self.log_man_ref.read_lock.acquire()
                    core_ent = self.entry
                    self.extra =self.log_man_ref.get_content(core_ent)
                    return self.extra
                finally :
                    self.log_man_ref.read_lock.release()
    def date_obj(self):
        &#34;&#34;&#34;return date as a datetime object to allow for actual date arithmetics instead of boolean comparison the ISO string format allows&#34;&#34;&#34;
        return datetime.fromisoformat(self.entry.date)

    def __lt__(self, other):
        return self.date&lt;other.date if other is not None else False
    def __gt__(self, other):
        return self.date&gt;other.date if other is not None else True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orea.loglib.LogEntry"><code class="flex name class">
<span>class <span class="ident">LogEntry</span></span>
<span>(</span><span>log_man: <a title="orea.loglib.LogManagerWrapper" href="#orea.loglib.LogManagerWrapper">LogManagerWrapper</a>, entry: LogEntryCore)</span>
</code></dt>
<dd>
<div class="desc"><p>wrapper around LogEntryCore to allow more ergonomic deserialization by keeping references to LogManagerWrapper objects</p>
<p>:ivar log_man_ref: reference to the LogManagerWrapper which created the file
:ivar entry: LogEntryCore defined in the rust API containing header info and byte extension
:ivar extra: stores extra content after the function was called to avoid multiple costly deserializations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogEntry :
    &#34;&#34;&#34;
    wrapper around LogEntryCore to allow more ergonomic deserialization by keeping references to LogManagerWrapper objects

    :ivar log_man_ref: reference to the LogManagerWrapper which created the file
    :ivar entry: LogEntryCore defined in the rust API containing header info and byte extension
    :ivar extra: stores extra content after the function was called to avoid multiple costly deserializations&#34;&#34;&#34;

    def __init__(self,log_man:LogManagerWrapper,entry : orea_core.LogEntryCore):
        self.log_man_ref = log_man
        self.entry = entry
        self.extra = {} #store content in case of deserialization to avoid loading it several times

    def __getattr__(self, item):
        if item in [&#34;date&#34;,&#34;level&#34;,&#34;message&#34;,&#34;topic&#34;,&#34;dic_extension&#34;,&#34;total_extension&#34;]:
            return getattr(self.entry,item)
        elif item == &#34;log_man_ref&#34; :
            return self.log_man_ref
        elif item == &#34;entry&#34; :
            return self.entry
        else :
            raise KeyError(f&#34; &#39;Logentry&#39; object has no attribute {item}&#34;)

    def __repr__(self):
        return self.entry.__repr__()
    def deserialize(self):
        &#34;&#34;&#34;use deserialization function of LogManager. stores the result in the object to avoid loading it several times&#34;&#34;&#34;
        if self.dic_extension[1] == 0:
            return None
        else:

            if self.extra :
                return self.extra
            else :

                try :
                    self.log_man_ref.read_lock.acquire()
                    core_ent = self.entry
                    self.extra =self.log_man_ref.get_content(core_ent)
                    return self.extra
                finally :
                    self.log_man_ref.read_lock.release()
    def date_obj(self):
        &#34;&#34;&#34;return date as a datetime object to allow for actual date arithmetics instead of boolean comparison the ISO string format allows&#34;&#34;&#34;
        return datetime.fromisoformat(self.entry.date)

    def __lt__(self, other):
        return self.date&lt;other.date if other is not None else False
    def __gt__(self, other):
        return self.date&gt;other.date if other is not None else True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orea.loglib.LogEntry.date_obj"><code class="name flex">
<span>def <span class="ident">date_obj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return date as a datetime object to allow for actual date arithmetics instead of boolean comparison the ISO string format allows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_obj(self):
    &#34;&#34;&#34;return date as a datetime object to allow for actual date arithmetics instead of boolean comparison the ISO string format allows&#34;&#34;&#34;
    return datetime.fromisoformat(self.entry.date)</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogEntry.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>use deserialization function of LogManager. stores the result in the object to avoid loading it several times</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self):
    &#34;&#34;&#34;use deserialization function of LogManager. stores the result in the object to avoid loading it several times&#34;&#34;&#34;
    if self.dic_extension[1] == 0:
        return None
    else:

        if self.extra :
            return self.extra
        else :

            try :
                self.log_man_ref.read_lock.acquire()
                core_ent = self.entry
                self.extra =self.log_man_ref.get_content(core_ent)
                return self.extra
            finally :
                self.log_man_ref.read_lock.release()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="orea.loglib.LogLevels"><code class="flex name class">
<span>class <span class="ident">LogLevels</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogLevels(Enum) : #classic log levels for most applications
    FATAL = 0
    ERROR = 1
    WARN = 2
    INFO = 3
    DEBUG = 4
    TRACE = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orea.loglib.LogLevels.DEBUG"><code class="name">var <span class="ident">DEBUG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orea.loglib.LogLevels.ERROR"><code class="name">var <span class="ident">ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orea.loglib.LogLevels.FATAL"><code class="name">var <span class="ident">FATAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orea.loglib.LogLevels.INFO"><code class="name">var <span class="ident">INFO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orea.loglib.LogLevels.TRACE"><code class="name">var <span class="ident">TRACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="orea.loglib.LogLevels.WARN"><code class="name">var <span class="ident">WARN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="orea.loglib.LogManagerWrapper"><code class="flex name class">
<span>class <span class="ident">LogManagerWrapper</span></span>
<span>(</span><span>fpath, deque_max_len=20)</span>
</code></dt>
<dd>
<div class="desc"><p>wrapper on LogManager rust struct providing convenience functions and type conversions to Rust compatible types.</p>
<p>ctor, initializes a LogManager object and a deque for entries.</p>
<p>:param str fpath : tracked .yaml file
:param int deque_max_len : size of the entry deque. default 20</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogManagerWrapper :
    &#34;&#34;&#34;wrapper on LogManager rust struct providing convenience functions and type conversions to Rust compatible types.&#34;&#34;&#34;
    def __init__(self,fpath, deque_max_len = 20):
        &#34;&#34;&#34;ctor, initializes a LogManager object and a deque for entries.

        :param str fpath : tracked .yaml file
        :param int deque_max_len : size of the entry deque. default 20&#34;&#34;&#34;
        fpath = os.path.abspath(fpath)
        if not os.path.exists(fpath):
            open(fpath, &#39;w+&#39;).close()
        self._logmanager = orea_core.LogManager(fpath)
        self.file = open(fpath, &#39;a&#39;, encoding=&#34;utf-8&#34;)
        self.path = self._logmanager.file_name

        self.queue = deque(maxlen=deque_max_len)
        self.cursor_date = None #will stay None if empty file
        self.write_lock = Lock()
        self.read_lock = Lock() #deserialization

        self.pause= False

        last_entry = self.current_entry()
        if last_entry is not None :
            self.queue.append(last_entry)
            self.cursor_date = datetime.fromisoformat(last_entry.date)


        self.search_timeout = DEFAULT_CRAWL_TIMEOUT


    #slice_up/slice_down c
    def _scroll_up(self,n, header_cond_function = None, content_cond_function = None,inf_scroll = False) :
        &#34;&#34;&#34;collect documents from the current one going up in the bound file (previous entries) and appends them in the deque, optionally filtering them using a header and content
    #filtering function. moves the cursor up the file.

    :param func header_cond_function : filtering function with an access to every LogEntryField except the deserialized content
    :param func content_cond_function : filtering function also accounting for deserialized content
    :param bool inf_scroll : ignore search timeout. default : False&#34;&#34;&#34;
        result = 0
        if len(self.queue)!=0 and self.queue[0] is not None:
            self._logmanager.byte_jump( self.queue[0].total_extension[0] + self.queue[0].total_extension[1]//2) #set cursor position to earliest entry
        for i in range(n) :
            result = self.crawl_until(-1,header_cond_function,content_cond_function,inf_scroll)
        return result

    def _scroll_down(self, n, header_cond_function = None, content_cond_function = None,inf_scroll = False) :
        &#34;&#34;&#34;same as scroll_up in opposite direction&#34;&#34;&#34;
        result = 0
        if len(self.queue)!=0 and self.queue[-1] is not None:
            self._logmanager.byte_jump(self.queue[-1].total_extension[0] + self.queue[-1].total_extension[1] // 2)  # set cursor position to latest entry
        for i in range(n):
            result = self.crawl_until(1, header_cond_function, content_cond_function,inf_scroll)
        return result
    def scroll(self, n, header_cond_function = None, content_cond_function = None , inf_scroll = False) :
        &#34;&#34;&#34;calls scroll_up and scroll_down multiple time to move along the document.

        :param int n : amount of valid entries we go over.&#34;&#34;&#34;
        if n == 0:
            return None
        elif n &gt; 0 :
            counter = 0
            scroll_res = 0
            while counter &lt; n and scroll_res is not None :
                counter+=1
                scroll_res = self._scroll_down(1, header_cond_function, content_cond_function,inf_scroll)
            if scroll_res is None :
                return None
        else :
            counter = 0
            scroll_res = 0
            while counter &lt; -n and scroll_res is not None :
                counter+=1
                scroll_res = self._scroll_up(1, header_cond_function, content_cond_function,inf_scroll)
            if scroll_res is None :
                return None


    def crawl_until(self,direction : int, header_cond_function = None, content_cond_function = None, inf_scroll = False):
        &#34;&#34;&#34;moves along the file until an entry meets search criteria, stores it in the queue&#34;&#34;&#34;

        if header_cond_function is None and content_cond_function is None :
            if direction &lt; 0 :
                self.move(-1)
                ent = self.current_entry()
                if ent is not None :
                    if len(self.queue)!=0 and self.queue[0] is not None :

                        if not ent.total_extension[0]==self.queue[0].total_extension[0]==0 :
                            self.queue.appendleft(ent)
                else :
                    return None
            elif direction &gt; 0 :
                self.move(1)
                ent = self.current_entry()
                if ent is not None:
                    if len(self.queue) != 0 and  self.queue[-1] is not None :
                        if not ent.total_extension[0]==self.queue[-1].total_extension[0]:
                            self.queue.append(ent)
                else :
                    return None
            return 0

        increment = -1 if direction &lt;0 else 1

        if (inf_scroll == False) and (self.nothing_down_close and increment == 1) or (self.nothing_up_close and increment ==-1) :
            return

        entry = self.current_entry()
        cur_date = self.current_entry().date_obj()
        moved = 0
        while True :

            self.move(increment)
            moved +=1
            entry = self.current_entry()

            if entry is None : #either end of file, return None as stop condition for filling function
                return None


            stop_condition = True
            if content_cond_function is not None:
                stop_condition = stop_condition and content_cond_function(entry)
            if header_cond_function is not None :
                stop_condition = stop_condition and header_cond_function(entry)

            if inf_scroll == False and abs(entry.date_obj() - cur_date) &gt; self.search_timeout :
                if increment == 1:
                    self.nothing_down_close = True
                else :
                    self.nothing_up_close = True
                return -1


            extremal_condition = entry.total_extension[0]==0 or self.isateof()
                     #check if document is at either end of file

            if stop_condition : #condition met, add to queue
                break

            if extremal_condition : #end of file reached and condition not met, leave
                return None

        if increment  == -1 and entry is not None:
            if len(self.queue)==0 or (len(self.queue)!=0 and entry.total_extension[0]!=self.queue[0].total_extension[0]):
                self.queue.appendleft(entry)
                self.nothing_down_close = False #allows going back to previous entries
        if increment == 1 and entry is not None:
            if len(self.queue)==0 or entry.total_extension[0]!=self.queue[-1].total_extension[0]:
                self.queue.append(entry)
                self.nothing_up_close = False
        return moved

    def fill_queue(self,direction = -1, header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;fill entry queue in either direction using optional filtering functions&#34;&#34;&#34;
        increment = -1 if direction &lt; 0 else 1
        space_left = self.queue.maxlen -1 #keep the starting entry somewhere in queue

        if header_cond_function is None and content_cond_function is None :
            if direction &lt;0 :
                self.queue.clear()
                self.queue.append(self.current_entry())
                self._scroll_up(space_left)
            else :
                self.queue.clear()
                self.queue.append(self.current_entry())
                self._scroll_down(space_left)

        else :

            self.queue.clear()
            cur_ent = self.current_entry()
            if cur_ent is not None :
                current_fits = True
                if header_cond_function is not None :
                    current_fits = current_fits and header_cond_function(cur_ent.entry)
                if content_cond_function is not None :
                    current_fits = current_fits and content_cond_function(cur_ent)
                if current_fits :
                    self.queue.append(cur_ent)

            while space_left !=0 :

                res = self.crawl_until(direction,header_cond_function,content_cond_function)
                if res is None :
                    return
                else :
                    space_left -= 1


    def position_percent(self):
        &#34;&#34;&#34;returns the percentage of the current byte position to the total file length. &#34;&#34;&#34;
        return self._logmanager.current_doc_extend[0]/self._logmanager.file_byte_len()

    def isateof(self):
        &#34;&#34;&#34;compare current doc extension to file size to check if the cursor is at the end of the file&#34;&#34;&#34;
        return self._logmanager.file_byte_len() - (self._logmanager.current_doc_extend[0]+self._logmanager.current_doc_extend[1]) &lt; 10




    def search_date(self,date):
        &#34;&#34;&#34;moves to the entry with the specified date or the first one older than that. date should be a datetime object or an ISO date string &#34;&#34;&#34;

        self.nothing_up_close = False
        self.nothing_down_close = False

        if isinstance(date,datetime):
            self._logmanager.search_date(str(date))
        else :
            self._logmanager.search_date(date)

    def move(self,amount : int) :
        &#34;&#34;&#34;move along documents, direction specified by sign of amount.
        moving past the last or first document places the cursor back on the extremal document and return None, so does
        calling move on an empty file.
        &#34;&#34;&#34;

        if amount == 0 :
            return None

        self._logmanager.move_doc(amount)
        if self.current_entry() is not None :
            self.cursor_date = datetime.fromisoformat(self.current_entry().date)
        else : #case of empty file
            if self._logmanager.file_byte_len()&gt;0 and amount &gt; 0 :
                self.jump_last(refill=False)
            return None

    def get_content(self,entry : orea_core.LogEntryCore) -&gt; dict :
        &#34;&#34;&#34;get optional content from a LogEntryObject as a dict. You should favor using the deserialize method of a LogEntry to get contents, it will call this one on itself.&#34;&#34;&#34;
        text =self._logmanager.get_content(entry).replace(&#34;---\n&#34;,&#39;&#39;)
        return yaml.load(self._logmanager.get_content(entry),yaml.Loader)

    def date_interval(self,d1 :datetime.date ,d2 : datetime.date, cond_func = None):
        &#34;&#34;&#34;returns all entries between two date objects (or any object for which __repr__ returns an ISO formated date string,
        which also optionally meet a user defined criterium using a function of signature&#34;&#34;&#34;

        all_slice = self._logmanager.date_interval(str(d1),str(d2),None)
        if cond_func is None :
            return all_slice
        else :
            return [entry for entry in all_slice if cond_func(self,entry)==True]

    def current_entry(self):
        &#34;&#34;&#34;return the LogEntry the file cursor is currently pointing to&#34;&#34;&#34;
        core_ent = self._logmanager.current_entry()
        return LogEntry(self,core_ent) if core_ent is not None else None

    def current_core_entry(self):
        &#34;&#34;&#34;return the LogEntryCore the file cursor is currently pointing to&#34;&#34;&#34;
        return self._logmanager.current_entry()


    def jump_first(self,refill = True,header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;move to beginning of file.
        :param bool refill : if True, reset the entry deque
        :param header_cond_function : header filter function used if refilling
        :param content_cond_function :content filter&#34;&#34;&#34;
        self.nothing_up_close = False
        self.nothing_down_close = False

        self._logmanager.jump_first()
        first_ent = self.current_entry()
        if len(self.queue)!=0 and first_ent == self.queue[0]:
            return
        else :
            if refill :
                self.fill_queue(1,header_cond_function,content_cond_function)
            return len(self.queue)
        return 0


    def jump_last(self,refill=True,header_cond_function = None, content_cond_function = None):
        &#34;&#34;&#34;Move to EoF, optional refill of deque&#34;&#34;&#34;

        self.nothing_up_close = False
        self.nothing_down_close = False

        self._logmanager.jump_last()
        last_ent = self.current_entry()
        if len(self.queue)!=0 and last_ent == self.queue[-1]:
            return
        else:
            if refill:
                self.fill_queue(-1, header_cond_function, content_cond_function)
            return len(self.queue)
        return 0

    def new_entry(self,message =&#34;&#34;, level=0, topic = &#34;&#34;, serialize_dict = None) :
        &#34;&#34;&#34;add new entry to the file the manager object is connected to.

        :param str message : entry message
        :param int level : entry log level. should be between 0-99
        :param str topic : entry topic, used for filtering later
        :param serialize_dict : oprional dictionary serialized as YAML and appended to the file along with the rest&#34;&#34;&#34;

        date = datetime.now()
        _level = level.value if isinstance(level, Enum) else level



        with self.write_lock:
            if not serialize_dict:  # print message directly without yaml dumping, saves a bit of performance
                self.file.seek(os.SEEK_END)
                self.file.write(
                    &#34;date: {}\nlevel: {}\ntopic: {}\nmessage: {}\n---\n&#34;.format(date, _level, topic, message))
                self.file.flush()
                return

            content_dict = {&#34;date&#34;:date,&#34;level&#34;:_level,&#34;topic&#34;:topic,&#34;message&#34;:message}
            content_dict.update(serialize_dict)
            content_str = yaml.dump(content_dict, sort_keys=False, allow_unicode=True)+&#39;---\n&#39;
            self.file.write(content_str)
            self.file.flush()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orea.loglib.LogManagerWrapper.crawl_until"><code class="name flex">
<span>def <span class="ident">crawl_until</span></span>(<span>self, direction: int, header_cond_function=None, content_cond_function=None, inf_scroll=False)</span>
</code></dt>
<dd>
<div class="desc"><p>moves along the file until an entry meets search criteria, stores it in the queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crawl_until(self,direction : int, header_cond_function = None, content_cond_function = None, inf_scroll = False):
    &#34;&#34;&#34;moves along the file until an entry meets search criteria, stores it in the queue&#34;&#34;&#34;

    if header_cond_function is None and content_cond_function is None :
        if direction &lt; 0 :
            self.move(-1)
            ent = self.current_entry()
            if ent is not None :
                if len(self.queue)!=0 and self.queue[0] is not None :

                    if not ent.total_extension[0]==self.queue[0].total_extension[0]==0 :
                        self.queue.appendleft(ent)
            else :
                return None
        elif direction &gt; 0 :
            self.move(1)
            ent = self.current_entry()
            if ent is not None:
                if len(self.queue) != 0 and  self.queue[-1] is not None :
                    if not ent.total_extension[0]==self.queue[-1].total_extension[0]:
                        self.queue.append(ent)
            else :
                return None
        return 0

    increment = -1 if direction &lt;0 else 1

    if (inf_scroll == False) and (self.nothing_down_close and increment == 1) or (self.nothing_up_close and increment ==-1) :
        return

    entry = self.current_entry()
    cur_date = self.current_entry().date_obj()
    moved = 0
    while True :

        self.move(increment)
        moved +=1
        entry = self.current_entry()

        if entry is None : #either end of file, return None as stop condition for filling function
            return None


        stop_condition = True
        if content_cond_function is not None:
            stop_condition = stop_condition and content_cond_function(entry)
        if header_cond_function is not None :
            stop_condition = stop_condition and header_cond_function(entry)

        if inf_scroll == False and abs(entry.date_obj() - cur_date) &gt; self.search_timeout :
            if increment == 1:
                self.nothing_down_close = True
            else :
                self.nothing_up_close = True
            return -1


        extremal_condition = entry.total_extension[0]==0 or self.isateof()
                 #check if document is at either end of file

        if stop_condition : #condition met, add to queue
            break

        if extremal_condition : #end of file reached and condition not met, leave
            return None

    if increment  == -1 and entry is not None:
        if len(self.queue)==0 or (len(self.queue)!=0 and entry.total_extension[0]!=self.queue[0].total_extension[0]):
            self.queue.appendleft(entry)
            self.nothing_down_close = False #allows going back to previous entries
    if increment == 1 and entry is not None:
        if len(self.queue)==0 or entry.total_extension[0]!=self.queue[-1].total_extension[0]:
            self.queue.append(entry)
            self.nothing_up_close = False
    return moved</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.current_core_entry"><code class="name flex">
<span>def <span class="ident">current_core_entry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the LogEntryCore the file cursor is currently pointing to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_core_entry(self):
    &#34;&#34;&#34;return the LogEntryCore the file cursor is currently pointing to&#34;&#34;&#34;
    return self._logmanager.current_entry()</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.current_entry"><code class="name flex">
<span>def <span class="ident">current_entry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the LogEntry the file cursor is currently pointing to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_entry(self):
    &#34;&#34;&#34;return the LogEntry the file cursor is currently pointing to&#34;&#34;&#34;
    core_ent = self._logmanager.current_entry()
    return LogEntry(self,core_ent) if core_ent is not None else None</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.date_interval"><code class="name flex">
<span>def <span class="ident">date_interval</span></span>(<span>self, d1: <method 'date' of 'datetime.datetime' objects>, d2: <method 'date' of 'datetime.datetime' objects>, cond_func=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns all entries between two date objects (or any object for which <strong>repr</strong> returns an ISO formated date string,
which also optionally meet a user defined criterium using a function of signature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_interval(self,d1 :datetime.date ,d2 : datetime.date, cond_func = None):
    &#34;&#34;&#34;returns all entries between two date objects (or any object for which __repr__ returns an ISO formated date string,
    which also optionally meet a user defined criterium using a function of signature&#34;&#34;&#34;

    all_slice = self._logmanager.date_interval(str(d1),str(d2),None)
    if cond_func is None :
        return all_slice
    else :
        return [entry for entry in all_slice if cond_func(self,entry)==True]</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.fill_queue"><code class="name flex">
<span>def <span class="ident">fill_queue</span></span>(<span>self, direction=-1, header_cond_function=None, content_cond_function=None)</span>
</code></dt>
<dd>
<div class="desc"><p>fill entry queue in either direction using optional filtering functions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_queue(self,direction = -1, header_cond_function = None, content_cond_function = None):
    &#34;&#34;&#34;fill entry queue in either direction using optional filtering functions&#34;&#34;&#34;
    increment = -1 if direction &lt; 0 else 1
    space_left = self.queue.maxlen -1 #keep the starting entry somewhere in queue

    if header_cond_function is None and content_cond_function is None :
        if direction &lt;0 :
            self.queue.clear()
            self.queue.append(self.current_entry())
            self._scroll_up(space_left)
        else :
            self.queue.clear()
            self.queue.append(self.current_entry())
            self._scroll_down(space_left)

    else :

        self.queue.clear()
        cur_ent = self.current_entry()
        if cur_ent is not None :
            current_fits = True
            if header_cond_function is not None :
                current_fits = current_fits and header_cond_function(cur_ent.entry)
            if content_cond_function is not None :
                current_fits = current_fits and content_cond_function(cur_ent)
            if current_fits :
                self.queue.append(cur_ent)

        while space_left !=0 :

            res = self.crawl_until(direction,header_cond_function,content_cond_function)
            if res is None :
                return
            else :
                space_left -= 1</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.get_content"><code class="name flex">
<span>def <span class="ident">get_content</span></span>(<span>self, entry: LogEntryCore) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>get optional content from a LogEntryObject as a dict. You should favor using the deserialize method of a LogEntry to get contents, it will call this one on itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content(self,entry : orea_core.LogEntryCore) -&gt; dict :
    &#34;&#34;&#34;get optional content from a LogEntryObject as a dict. You should favor using the deserialize method of a LogEntry to get contents, it will call this one on itself.&#34;&#34;&#34;
    text =self._logmanager.get_content(entry).replace(&#34;---\n&#34;,&#39;&#39;)
    return yaml.load(self._logmanager.get_content(entry),yaml.Loader)</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.isateof"><code class="name flex">
<span>def <span class="ident">isateof</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>compare current doc extension to file size to check if the cursor is at the end of the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isateof(self):
    &#34;&#34;&#34;compare current doc extension to file size to check if the cursor is at the end of the file&#34;&#34;&#34;
    return self._logmanager.file_byte_len() - (self._logmanager.current_doc_extend[0]+self._logmanager.current_doc_extend[1]) &lt; 10</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.jump_first"><code class="name flex">
<span>def <span class="ident">jump_first</span></span>(<span>self, refill=True, header_cond_function=None, content_cond_function=None)</span>
</code></dt>
<dd>
<div class="desc"><p>move to beginning of file.
:param bool refill : if True, reset the entry deque
:param header_cond_function : header filter function used if refilling
:param content_cond_function :content filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump_first(self,refill = True,header_cond_function = None, content_cond_function = None):
    &#34;&#34;&#34;move to beginning of file.
    :param bool refill : if True, reset the entry deque
    :param header_cond_function : header filter function used if refilling
    :param content_cond_function :content filter&#34;&#34;&#34;
    self.nothing_up_close = False
    self.nothing_down_close = False

    self._logmanager.jump_first()
    first_ent = self.current_entry()
    if len(self.queue)!=0 and first_ent == self.queue[0]:
        return
    else :
        if refill :
            self.fill_queue(1,header_cond_function,content_cond_function)
        return len(self.queue)
    return 0</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.jump_last"><code class="name flex">
<span>def <span class="ident">jump_last</span></span>(<span>self, refill=True, header_cond_function=None, content_cond_function=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move to EoF, optional refill of deque</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump_last(self,refill=True,header_cond_function = None, content_cond_function = None):
    &#34;&#34;&#34;Move to EoF, optional refill of deque&#34;&#34;&#34;

    self.nothing_up_close = False
    self.nothing_down_close = False

    self._logmanager.jump_last()
    last_ent = self.current_entry()
    if len(self.queue)!=0 and last_ent == self.queue[-1]:
        return
    else:
        if refill:
            self.fill_queue(-1, header_cond_function, content_cond_function)
        return len(self.queue)
    return 0</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, amount: int)</span>
</code></dt>
<dd>
<div class="desc"><p>move along documents, direction specified by sign of amount.
moving past the last or first document places the cursor back on the extremal document and return None, so does
calling move on an empty file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self,amount : int) :
    &#34;&#34;&#34;move along documents, direction specified by sign of amount.
    moving past the last or first document places the cursor back on the extremal document and return None, so does
    calling move on an empty file.
    &#34;&#34;&#34;

    if amount == 0 :
        return None

    self._logmanager.move_doc(amount)
    if self.current_entry() is not None :
        self.cursor_date = datetime.fromisoformat(self.current_entry().date)
    else : #case of empty file
        if self._logmanager.file_byte_len()&gt;0 and amount &gt; 0 :
            self.jump_last(refill=False)
        return None</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.new_entry"><code class="name flex">
<span>def <span class="ident">new_entry</span></span>(<span>self, message='', level=0, topic='', serialize_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>add new entry to the file the manager object is connected to.</p>
<p>:param str message : entry message
:param int level : entry log level. should be between 0-99
:param str topic : entry topic, used for filtering later
:param serialize_dict : oprional dictionary serialized as YAML and appended to the file along with the rest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_entry(self,message =&#34;&#34;, level=0, topic = &#34;&#34;, serialize_dict = None) :
    &#34;&#34;&#34;add new entry to the file the manager object is connected to.

    :param str message : entry message
    :param int level : entry log level. should be between 0-99
    :param str topic : entry topic, used for filtering later
    :param serialize_dict : oprional dictionary serialized as YAML and appended to the file along with the rest&#34;&#34;&#34;

    date = datetime.now()
    _level = level.value if isinstance(level, Enum) else level



    with self.write_lock:
        if not serialize_dict:  # print message directly without yaml dumping, saves a bit of performance
            self.file.seek(os.SEEK_END)
            self.file.write(
                &#34;date: {}\nlevel: {}\ntopic: {}\nmessage: {}\n---\n&#34;.format(date, _level, topic, message))
            self.file.flush()
            return

        content_dict = {&#34;date&#34;:date,&#34;level&#34;:_level,&#34;topic&#34;:topic,&#34;message&#34;:message}
        content_dict.update(serialize_dict)
        content_str = yaml.dump(content_dict, sort_keys=False, allow_unicode=True)+&#39;---\n&#39;
        self.file.write(content_str)
        self.file.flush()</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.position_percent"><code class="name flex">
<span>def <span class="ident">position_percent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the percentage of the current byte position to the total file length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_percent(self):
    &#34;&#34;&#34;returns the percentage of the current byte position to the total file length. &#34;&#34;&#34;
    return self._logmanager.current_doc_extend[0]/self._logmanager.file_byte_len()</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.scroll"><code class="name flex">
<span>def <span class="ident">scroll</span></span>(<span>self, n, header_cond_function=None, content_cond_function=None, inf_scroll=False)</span>
</code></dt>
<dd>
<div class="desc"><p>calls scroll_up and scroll_down multiple time to move along the document.</p>
<p>:param int n : amount of valid entries we go over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll(self, n, header_cond_function = None, content_cond_function = None , inf_scroll = False) :
    &#34;&#34;&#34;calls scroll_up and scroll_down multiple time to move along the document.

    :param int n : amount of valid entries we go over.&#34;&#34;&#34;
    if n == 0:
        return None
    elif n &gt; 0 :
        counter = 0
        scroll_res = 0
        while counter &lt; n and scroll_res is not None :
            counter+=1
            scroll_res = self._scroll_down(1, header_cond_function, content_cond_function,inf_scroll)
        if scroll_res is None :
            return None
    else :
        counter = 0
        scroll_res = 0
        while counter &lt; -n and scroll_res is not None :
            counter+=1
            scroll_res = self._scroll_up(1, header_cond_function, content_cond_function,inf_scroll)
        if scroll_res is None :
            return None</code></pre>
</details>
</dd>
<dt id="orea.loglib.LogManagerWrapper.search_date"><code class="name flex">
<span>def <span class="ident">search_date</span></span>(<span>self, date)</span>
</code></dt>
<dd>
<div class="desc"><p>moves to the entry with the specified date or the first one older than that. date should be a datetime object or an ISO date string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_date(self,date):
    &#34;&#34;&#34;moves to the entry with the specified date or the first one older than that. date should be a datetime object or an ISO date string &#34;&#34;&#34;

    self.nothing_up_close = False
    self.nothing_down_close = False

    if isinstance(date,datetime):
        self._logmanager.search_date(str(date))
    else :
        self._logmanager.search_date(date)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orea" href="index.html">orea</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orea.loglib.LogEntry" href="#orea.loglib.LogEntry">LogEntry</a></code></h4>
<ul class="">
<li><code><a title="orea.loglib.LogEntry.date_obj" href="#orea.loglib.LogEntry.date_obj">date_obj</a></code></li>
<li><code><a title="orea.loglib.LogEntry.deserialize" href="#orea.loglib.LogEntry.deserialize">deserialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orea.loglib.LogLevels" href="#orea.loglib.LogLevels">LogLevels</a></code></h4>
<ul class="two-column">
<li><code><a title="orea.loglib.LogLevels.DEBUG" href="#orea.loglib.LogLevels.DEBUG">DEBUG</a></code></li>
<li><code><a title="orea.loglib.LogLevels.ERROR" href="#orea.loglib.LogLevels.ERROR">ERROR</a></code></li>
<li><code><a title="orea.loglib.LogLevels.FATAL" href="#orea.loglib.LogLevels.FATAL">FATAL</a></code></li>
<li><code><a title="orea.loglib.LogLevels.INFO" href="#orea.loglib.LogLevels.INFO">INFO</a></code></li>
<li><code><a title="orea.loglib.LogLevels.TRACE" href="#orea.loglib.LogLevels.TRACE">TRACE</a></code></li>
<li><code><a title="orea.loglib.LogLevels.WARN" href="#orea.loglib.LogLevels.WARN">WARN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orea.loglib.LogManagerWrapper" href="#orea.loglib.LogManagerWrapper">LogManagerWrapper</a></code></h4>
<ul class="two-column">
<li><code><a title="orea.loglib.LogManagerWrapper.crawl_until" href="#orea.loglib.LogManagerWrapper.crawl_until">crawl_until</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.current_core_entry" href="#orea.loglib.LogManagerWrapper.current_core_entry">current_core_entry</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.current_entry" href="#orea.loglib.LogManagerWrapper.current_entry">current_entry</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.date_interval" href="#orea.loglib.LogManagerWrapper.date_interval">date_interval</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.fill_queue" href="#orea.loglib.LogManagerWrapper.fill_queue">fill_queue</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.get_content" href="#orea.loglib.LogManagerWrapper.get_content">get_content</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.isateof" href="#orea.loglib.LogManagerWrapper.isateof">isateof</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.jump_first" href="#orea.loglib.LogManagerWrapper.jump_first">jump_first</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.jump_last" href="#orea.loglib.LogManagerWrapper.jump_last">jump_last</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.move" href="#orea.loglib.LogManagerWrapper.move">move</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.new_entry" href="#orea.loglib.LogManagerWrapper.new_entry">new_entry</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.position_percent" href="#orea.loglib.LogManagerWrapper.position_percent">position_percent</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.scroll" href="#orea.loglib.LogManagerWrapper.scroll">scroll</a></code></li>
<li><code><a title="orea.loglib.LogManagerWrapper.search_date" href="#orea.loglib.LogManagerWrapper.search_date">search_date</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>