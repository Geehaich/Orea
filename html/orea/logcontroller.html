<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orea.logcontroller API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orea.logcontroller</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import rich
import sys
import os
from collections import deque

from .filtering import  default_header_func , BoolOps
from .loglib import LogManagerWrapper,LogLevels,LogEntry

from datetime import timedelta

LOG_EVENT_COLORS = [&#34;bold bright_red blink&#34;,&#34;bold orange_red1&#34;,&#34;bold orange1&#34;,&#34;bold violet&#34;,&#34;bold blue&#34;,&#34;bold&#34;]

class LogController :
    &#34;&#34;&#34;controller class for interfacing. will store multiple LogManagerWrapper objects to track several files and handle events.&#34;&#34;&#34;
    tribool = [True,False,None]
    def __init__(self,tracked_files : [str] , deque_size = 20):
        &#34;&#34;&#34;ctor creating LogManagerWrapper objects linked to each file, regrouping them in a dict, and setting default
        filter parameters.

        Parameters :

        [str] tracked_files : a list of paths pointing to .yaml file paths. The files will be created if they don&#39;t exist but their folder does.
        int deque_size : size of each LogManagerWrapper&#39;s entries deque. defaults to 20
        &#34;&#34;&#34;

        self.log_mans = {os.path.abspath(file): LogManagerWrapper(file,deque_max_len=deque_size) for file in tracked_files}
        &#34;&#34;&#34;dict regrouping individual logmanagers&#34;&#34;&#34;

        self.max_level = 5
        self.topic_substring = &#34;&#34;
        &#34;&#34;&#34;substring to search in topics during filtering&#34;&#34;&#34;
        self.message_substring = &#34;&#34;
        &#34;&#34;&#34;substring to search in message during filtering&#34;&#34;&#34;
        self.data_presence_idx = 2
        self.filter = None
        &#34;&#34;&#34;entry filtering function&#34;&#34;&#34;
        self.update_filter() #header filter

        self.search_timeout = timedelta(seconds = 180)
        &#34;&#34;&#34;timedelta object used as search timeout on all tracked wrappers&#34;&#34;&#34;
        self.set_timeout(self.search_timeout)


        self.est_total_entries = 0 #sum of estimated number for each logmanagerWrapper
        self.est_total()
        for man in self.log_mans:
            self.log_mans[man].fill_queue(-1,self.filter)

        self.sorted_entries = []
        &#34;&#34;&#34;a list used to aggregate entries and sort them by date for display&#34;&#34;&#34;
        self.contents_changed = False
        &#34;&#34;&#34;flag indicating sorted_entries need to be rebuilt&#34;&#34;&#34;
        self.collect_entries()


    def update_filter(self) -&gt; None:
        &#34;&#34;&#34;create a new header filtering function using parameters currently stored in the controller, raises content flag&#34;&#34;&#34;
        self.filter =  default_header_func(self.max_level,BoolOps.LESS_OR_EQUAL,self.topic_substring,
                                      self.message_substring,LogController.tribool[self.data_presence_idx])
        self.contents_changed = True


        for mankey in self.log_mans :


            logman = self.log_mans[mankey]
            logman.nothing_up_close = False #reset search timeouts
            logman.nothing_down_close = False
            if len(logman.queue)!=0 :
                logman._logmanager.byte_jump(logman.queue[-1].total_extension[0] + logman.queue[-1].total_extension[1]//2)
                logman.queue.clear()
                logman.fill_queue(-1,self.filter)


    def collect_entries(self):
        &#34;&#34;&#34;gather every currently stored entry into a list and sorts them by date.&#34;&#34;&#34;
        aggregated_entries = []
        self.sorted_entries.clear()
        for logman in self.log_mans :
            for entry in self.log_mans[logman].queue :
                if entry not in aggregated_entries : #duplicates sometimes at ends of file
                    aggregated_entries.append(entry)
        if aggregated_entries :
            self.sorted_entries = sorted(aggregated_entries,reverse=True)
        else :
            self.sorted_entries = []

        self.contents_changed = False


    def scroll(self,amount,inf_scroll=False):
        &#34;&#34;&#34;scroll along entries by moving along every tracked file, checking the dates, and only moving the relevant logmanagers

        parameters :
        int amount : the amount of times we&#39;ll attempt to scroll. goes to earlier entries if &lt;0, later otherwise
        bool inf_scroll : whether to ignore search timeout. used by UI live mode while going down the file.&#34;&#34;&#34;

        if amount == 0 :
            return

        if amount &lt; 0 :
            for i in range(-amount):
                self._scroll_up_once(inf_scroll)
        if amount &gt; 0 :
            for i in range(amount):
                self._scroll_down_once(inf_scroll)

        self.contents_changed = True

    def _scroll_down_once(self,inf_scroll):
        &#34;&#34;&#34;scroll every logmanager once, check the earliest new entry, and scroll the logmanagers not containing it back up

        parameters :
        bool inf_scroll : ignore search timeout&#34;&#34;&#34;

        moved_log_mans = {}
        for logman in self.log_mans:
            if  not self.log_mans[logman].isateof() :
                r = self.log_mans[logman].scroll(1,self.filter,inf_scroll=inf_scroll)
                if r is not None and r !=-1:
                    moved_log_mans[self.log_mans[logman]] = r
        entries = [logman.current_entry() for logman in moved_log_mans ]
        dates = [e.date for e in entries if e is not None]
        if not dates:
            return
        mindate = min(dates)
        for e in entries:
            if e is not None and e.date != mindate:
                e.log_man_ref.scroll(-1,self.filter)
                if e.log_man_ref.nothing_down_close :
                    e.log_man_ref.search_date(mindate)
                    e.log_man_ref.nothing_down_close = False


    def _scroll_up_once(self,inf_scroll):
        &#34;&#34;&#34;same as scroll_down_once but in the other direction&#34;&#34;&#34;
        moved_log_mans = {}
        for logman in self.log_mans :
            if len(self.log_mans[logman].queue)!=0 and self.log_mans[logman].queue[0].total_extension[0]!=0 :
                r = self.log_mans[logman].scroll(-1,self.filter,inf_scroll=inf_scroll)
                if r is not None :
                    moved_log_mans[self.log_mans[logman]] = r
        entries = [logman.current_entry() for logman in moved_log_mans]
        dates = [e.date for e in entries if e is not None]
        if not dates:
            return
        maxdate = max(dates)
        for e in entries :
            if e is not None and e.date != maxdate and moved_log_mans[self.log_mans[logman]]!=-1 :
                e.log_man_ref.scroll(1,self.filter)
                if e.log_man_ref.nothing_up_close :
                    e.log_man_ref.search_date(maxdate)
                    e.log_man_ref.nothing_up_close = False


    def jump_first(self):
        &#34;&#34;&#34;jump to the beginning of every tracked file and raise the contents_changed flag to have the entry list rebuilt later&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans:
            total += self.log_mans[logman].jump_first(header_cond_function=self.filter,refill=True) #jump first returns 0 if we were already at beginning
        if total !=0 :
            self.contents_changed = True


    def jump_last(self):
        &#34;&#34;&#34;jump to EoF for every tracked file&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans:
            total += self.log_mans[logman].jump_last(header_cond_function=self.filter,refill=True)  # jump first returns 0 if we were already at beginning
        if total !=0 :
            self.contents_changed = True
        self.contents_changed = True
    def search_date(self,date,refill=True):
        &#34;&#34;&#34;set the cursor for every LogmanagerWrapper to the first entry with a date &lt;= the date parameter.

        parameters :
        date|str date : a datetime or ISO date string representing the target date.
        bool refill : refill every tracked deque&#34;&#34;&#34;

        for logman in self.log_mans:
            self.log_mans[logman].search_date(date)
            if refill :
                self.log_mans[logman].fill_queue(-1,self.filter)
        self.contents_changed = True

    def set_timeout(self,timeout):
        &#34;&#34;&#34;set time search intervals for each logmanager, reset search flags&#34;&#34;&#34;
        self.search_timeout = timeout
        for logman in self.log_mans:
            self.log_mans[logman].search_timeout = timeout
        self.contents_changed = True


    def is_search_zone_limit(self):
        &#34;&#34;&#34;check if all LogManagers have timed out for display&#34;&#34;&#34;
        limit_down = True
        limit_up = True
        for log_man in self.log_mans :
            limit_up &amp;= self.log_mans[log_man].nothing_up_close
            limit_down &amp;= self.log_mans[log_man].nothing_down_close
        return limit_up,limit_down

    def mean_position(self):
        &#34;&#34;&#34;estimate of position of cursos in entries using the mean cursor position in files&#34;&#34;&#34;
        mean_p = 0
        i = 0
        for log_man in self.log_mans :
            mean_p += self.log_mans[log_man].position_percent()
            i +=1
        return round(mean_p/i*100,2)


    def all_eof(self):
        &#34;&#34;&#34;check if all logmanagers are at EoF to stop iterating in live mode&#34;&#34;&#34;
        for man in self.log_mans:
            if not self.log_mans[man].isateof():
                return False
        return True

    def est_total(self):
        &#34;&#34;&#34;randomly sample a few entries per logmanager for size, compare to file length and estimate a number of entries for all tracked files&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans :
            total +=  self.log_mans[logman]._logmanager.entry_size_estimate()
        self.est_total_entries = total</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orea.logcontroller.LogController"><code class="flex name class">
<span>class <span class="ident">LogController</span></span>
<span>(</span><span>tracked_files: [<class 'str'>], deque_size=20)</span>
</code></dt>
<dd>
<div class="desc"><p>controller class for interfacing. will store multiple LogManagerWrapper objects to track several files and handle events.</p>
<p>ctor creating LogManagerWrapper objects linked to each file, regrouping them in a dict, and setting default
filter parameters.</p>
<p>Parameters :</p>
<p>[str] tracked_files : a list of paths pointing to .yaml file paths. The files will be created if they don't exist but their folder does.
int deque_size : size of each LogManagerWrapper's entries deque. defaults to 20</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogController :
    &#34;&#34;&#34;controller class for interfacing. will store multiple LogManagerWrapper objects to track several files and handle events.&#34;&#34;&#34;
    tribool = [True,False,None]
    def __init__(self,tracked_files : [str] , deque_size = 20):
        &#34;&#34;&#34;ctor creating LogManagerWrapper objects linked to each file, regrouping them in a dict, and setting default
        filter parameters.

        Parameters :

        [str] tracked_files : a list of paths pointing to .yaml file paths. The files will be created if they don&#39;t exist but their folder does.
        int deque_size : size of each LogManagerWrapper&#39;s entries deque. defaults to 20
        &#34;&#34;&#34;

        self.log_mans = {os.path.abspath(file): LogManagerWrapper(file,deque_max_len=deque_size) for file in tracked_files}
        &#34;&#34;&#34;dict regrouping individual logmanagers&#34;&#34;&#34;

        self.max_level = 5
        self.topic_substring = &#34;&#34;
        &#34;&#34;&#34;substring to search in topics during filtering&#34;&#34;&#34;
        self.message_substring = &#34;&#34;
        &#34;&#34;&#34;substring to search in message during filtering&#34;&#34;&#34;
        self.data_presence_idx = 2
        self.filter = None
        &#34;&#34;&#34;entry filtering function&#34;&#34;&#34;
        self.update_filter() #header filter

        self.search_timeout = timedelta(seconds = 180)
        &#34;&#34;&#34;timedelta object used as search timeout on all tracked wrappers&#34;&#34;&#34;
        self.set_timeout(self.search_timeout)


        self.est_total_entries = 0 #sum of estimated number for each logmanagerWrapper
        self.est_total()
        for man in self.log_mans:
            self.log_mans[man].fill_queue(-1,self.filter)

        self.sorted_entries = []
        &#34;&#34;&#34;a list used to aggregate entries and sort them by date for display&#34;&#34;&#34;
        self.contents_changed = False
        &#34;&#34;&#34;flag indicating sorted_entries need to be rebuilt&#34;&#34;&#34;
        self.collect_entries()


    def update_filter(self) -&gt; None:
        &#34;&#34;&#34;create a new header filtering function using parameters currently stored in the controller, raises content flag&#34;&#34;&#34;
        self.filter =  default_header_func(self.max_level,BoolOps.LESS_OR_EQUAL,self.topic_substring,
                                      self.message_substring,LogController.tribool[self.data_presence_idx])
        self.contents_changed = True


        for mankey in self.log_mans :


            logman = self.log_mans[mankey]
            logman.nothing_up_close = False #reset search timeouts
            logman.nothing_down_close = False
            if len(logman.queue)!=0 :
                logman._logmanager.byte_jump(logman.queue[-1].total_extension[0] + logman.queue[-1].total_extension[1]//2)
                logman.queue.clear()
                logman.fill_queue(-1,self.filter)


    def collect_entries(self):
        &#34;&#34;&#34;gather every currently stored entry into a list and sorts them by date.&#34;&#34;&#34;
        aggregated_entries = []
        self.sorted_entries.clear()
        for logman in self.log_mans :
            for entry in self.log_mans[logman].queue :
                if entry not in aggregated_entries : #duplicates sometimes at ends of file
                    aggregated_entries.append(entry)
        if aggregated_entries :
            self.sorted_entries = sorted(aggregated_entries,reverse=True)
        else :
            self.sorted_entries = []

        self.contents_changed = False


    def scroll(self,amount,inf_scroll=False):
        &#34;&#34;&#34;scroll along entries by moving along every tracked file, checking the dates, and only moving the relevant logmanagers

        parameters :
        int amount : the amount of times we&#39;ll attempt to scroll. goes to earlier entries if &lt;0, later otherwise
        bool inf_scroll : whether to ignore search timeout. used by UI live mode while going down the file.&#34;&#34;&#34;

        if amount == 0 :
            return

        if amount &lt; 0 :
            for i in range(-amount):
                self._scroll_up_once(inf_scroll)
        if amount &gt; 0 :
            for i in range(amount):
                self._scroll_down_once(inf_scroll)

        self.contents_changed = True

    def _scroll_down_once(self,inf_scroll):
        &#34;&#34;&#34;scroll every logmanager once, check the earliest new entry, and scroll the logmanagers not containing it back up

        parameters :
        bool inf_scroll : ignore search timeout&#34;&#34;&#34;

        moved_log_mans = {}
        for logman in self.log_mans:
            if  not self.log_mans[logman].isateof() :
                r = self.log_mans[logman].scroll(1,self.filter,inf_scroll=inf_scroll)
                if r is not None and r !=-1:
                    moved_log_mans[self.log_mans[logman]] = r
        entries = [logman.current_entry() for logman in moved_log_mans ]
        dates = [e.date for e in entries if e is not None]
        if not dates:
            return
        mindate = min(dates)
        for e in entries:
            if e is not None and e.date != mindate:
                e.log_man_ref.scroll(-1,self.filter)
                if e.log_man_ref.nothing_down_close :
                    e.log_man_ref.search_date(mindate)
                    e.log_man_ref.nothing_down_close = False


    def _scroll_up_once(self,inf_scroll):
        &#34;&#34;&#34;same as scroll_down_once but in the other direction&#34;&#34;&#34;
        moved_log_mans = {}
        for logman in self.log_mans :
            if len(self.log_mans[logman].queue)!=0 and self.log_mans[logman].queue[0].total_extension[0]!=0 :
                r = self.log_mans[logman].scroll(-1,self.filter,inf_scroll=inf_scroll)
                if r is not None :
                    moved_log_mans[self.log_mans[logman]] = r
        entries = [logman.current_entry() for logman in moved_log_mans]
        dates = [e.date for e in entries if e is not None]
        if not dates:
            return
        maxdate = max(dates)
        for e in entries :
            if e is not None and e.date != maxdate and moved_log_mans[self.log_mans[logman]]!=-1 :
                e.log_man_ref.scroll(1,self.filter)
                if e.log_man_ref.nothing_up_close :
                    e.log_man_ref.search_date(maxdate)
                    e.log_man_ref.nothing_up_close = False


    def jump_first(self):
        &#34;&#34;&#34;jump to the beginning of every tracked file and raise the contents_changed flag to have the entry list rebuilt later&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans:
            total += self.log_mans[logman].jump_first(header_cond_function=self.filter,refill=True) #jump first returns 0 if we were already at beginning
        if total !=0 :
            self.contents_changed = True


    def jump_last(self):
        &#34;&#34;&#34;jump to EoF for every tracked file&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans:
            total += self.log_mans[logman].jump_last(header_cond_function=self.filter,refill=True)  # jump first returns 0 if we were already at beginning
        if total !=0 :
            self.contents_changed = True
        self.contents_changed = True
    def search_date(self,date,refill=True):
        &#34;&#34;&#34;set the cursor for every LogmanagerWrapper to the first entry with a date &lt;= the date parameter.

        parameters :
        date|str date : a datetime or ISO date string representing the target date.
        bool refill : refill every tracked deque&#34;&#34;&#34;

        for logman in self.log_mans:
            self.log_mans[logman].search_date(date)
            if refill :
                self.log_mans[logman].fill_queue(-1,self.filter)
        self.contents_changed = True

    def set_timeout(self,timeout):
        &#34;&#34;&#34;set time search intervals for each logmanager, reset search flags&#34;&#34;&#34;
        self.search_timeout = timeout
        for logman in self.log_mans:
            self.log_mans[logman].search_timeout = timeout
        self.contents_changed = True


    def is_search_zone_limit(self):
        &#34;&#34;&#34;check if all LogManagers have timed out for display&#34;&#34;&#34;
        limit_down = True
        limit_up = True
        for log_man in self.log_mans :
            limit_up &amp;= self.log_mans[log_man].nothing_up_close
            limit_down &amp;= self.log_mans[log_man].nothing_down_close
        return limit_up,limit_down

    def mean_position(self):
        &#34;&#34;&#34;estimate of position of cursos in entries using the mean cursor position in files&#34;&#34;&#34;
        mean_p = 0
        i = 0
        for log_man in self.log_mans :
            mean_p += self.log_mans[log_man].position_percent()
            i +=1
        return round(mean_p/i*100,2)


    def all_eof(self):
        &#34;&#34;&#34;check if all logmanagers are at EoF to stop iterating in live mode&#34;&#34;&#34;
        for man in self.log_mans:
            if not self.log_mans[man].isateof():
                return False
        return True

    def est_total(self):
        &#34;&#34;&#34;randomly sample a few entries per logmanager for size, compare to file length and estimate a number of entries for all tracked files&#34;&#34;&#34;
        total = 0
        for logman in self.log_mans :
            total +=  self.log_mans[logman]._logmanager.entry_size_estimate()
        self.est_total_entries = total</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="orea.logcontroller.LogController.tribool"><code class="name">var <span class="ident">tribool</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="orea.logcontroller.LogController.contents_changed"><code class="name">var <span class="ident">contents_changed</span></code></dt>
<dd>
<div class="desc"><p>flag indicating sorted_entries need to be rebuilt</p></div>
</dd>
<dt id="orea.logcontroller.LogController.filter"><code class="name">var <span class="ident">filter</span></code></dt>
<dd>
<div class="desc"><p>entry filtering function</p></div>
</dd>
<dt id="orea.logcontroller.LogController.log_mans"><code class="name">var <span class="ident">log_mans</span></code></dt>
<dd>
<div class="desc"><p>dict regrouping individual logmanagers</p></div>
</dd>
<dt id="orea.logcontroller.LogController.message_substring"><code class="name">var <span class="ident">message_substring</span></code></dt>
<dd>
<div class="desc"><p>substring to search in message during filtering</p></div>
</dd>
<dt id="orea.logcontroller.LogController.search_timeout"><code class="name">var <span class="ident">search_timeout</span></code></dt>
<dd>
<div class="desc"><p>timedelta object used as search timeout on all tracked wrappers</p></div>
</dd>
<dt id="orea.logcontroller.LogController.sorted_entries"><code class="name">var <span class="ident">sorted_entries</span></code></dt>
<dd>
<div class="desc"><p>a list used to aggregate entries and sort them by date for display</p></div>
</dd>
<dt id="orea.logcontroller.LogController.topic_substring"><code class="name">var <span class="ident">topic_substring</span></code></dt>
<dd>
<div class="desc"><p>substring to search in topics during filtering</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orea.logcontroller.LogController.all_eof"><code class="name flex">
<span>def <span class="ident">all_eof</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if all logmanagers are at EoF to stop iterating in live mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_eof(self):
    &#34;&#34;&#34;check if all logmanagers are at EoF to stop iterating in live mode&#34;&#34;&#34;
    for man in self.log_mans:
        if not self.log_mans[man].isateof():
            return False
    return True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.collect_entries"><code class="name flex">
<span>def <span class="ident">collect_entries</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>gather every currently stored entry into a list and sorts them by date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_entries(self):
    &#34;&#34;&#34;gather every currently stored entry into a list and sorts them by date.&#34;&#34;&#34;
    aggregated_entries = []
    self.sorted_entries.clear()
    for logman in self.log_mans :
        for entry in self.log_mans[logman].queue :
            if entry not in aggregated_entries : #duplicates sometimes at ends of file
                aggregated_entries.append(entry)
    if aggregated_entries :
        self.sorted_entries = sorted(aggregated_entries,reverse=True)
    else :
        self.sorted_entries = []

    self.contents_changed = False</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.est_total"><code class="name flex">
<span>def <span class="ident">est_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>randomly sample a few entries per logmanager for size, compare to file length and estimate a number of entries for all tracked files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def est_total(self):
    &#34;&#34;&#34;randomly sample a few entries per logmanager for size, compare to file length and estimate a number of entries for all tracked files&#34;&#34;&#34;
    total = 0
    for logman in self.log_mans :
        total +=  self.log_mans[logman]._logmanager.entry_size_estimate()
    self.est_total_entries = total</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.is_search_zone_limit"><code class="name flex">
<span>def <span class="ident">is_search_zone_limit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>check if all LogManagers have timed out for display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_search_zone_limit(self):
    &#34;&#34;&#34;check if all LogManagers have timed out for display&#34;&#34;&#34;
    limit_down = True
    limit_up = True
    for log_man in self.log_mans :
        limit_up &amp;= self.log_mans[log_man].nothing_up_close
        limit_down &amp;= self.log_mans[log_man].nothing_down_close
    return limit_up,limit_down</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.jump_first"><code class="name flex">
<span>def <span class="ident">jump_first</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>jump to the beginning of every tracked file and raise the contents_changed flag to have the entry list rebuilt later</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump_first(self):
    &#34;&#34;&#34;jump to the beginning of every tracked file and raise the contents_changed flag to have the entry list rebuilt later&#34;&#34;&#34;
    total = 0
    for logman in self.log_mans:
        total += self.log_mans[logman].jump_first(header_cond_function=self.filter,refill=True) #jump first returns 0 if we were already at beginning
    if total !=0 :
        self.contents_changed = True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.jump_last"><code class="name flex">
<span>def <span class="ident">jump_last</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>jump to EoF for every tracked file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump_last(self):
    &#34;&#34;&#34;jump to EoF for every tracked file&#34;&#34;&#34;
    total = 0
    for logman in self.log_mans:
        total += self.log_mans[logman].jump_last(header_cond_function=self.filter,refill=True)  # jump first returns 0 if we were already at beginning
    if total !=0 :
        self.contents_changed = True
    self.contents_changed = True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.mean_position"><code class="name flex">
<span>def <span class="ident">mean_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>estimate of position of cursos in entries using the mean cursor position in files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_position(self):
    &#34;&#34;&#34;estimate of position of cursos in entries using the mean cursor position in files&#34;&#34;&#34;
    mean_p = 0
    i = 0
    for log_man in self.log_mans :
        mean_p += self.log_mans[log_man].position_percent()
        i +=1
    return round(mean_p/i*100,2)</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.scroll"><code class="name flex">
<span>def <span class="ident">scroll</span></span>(<span>self, amount, inf_scroll=False)</span>
</code></dt>
<dd>
<div class="desc"><p>scroll along entries by moving along every tracked file, checking the dates, and only moving the relevant logmanagers</p>
<p>parameters :
int amount : the amount of times we'll attempt to scroll. goes to earlier entries if &lt;0, later otherwise
bool inf_scroll : whether to ignore search timeout. used by UI live mode while going down the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll(self,amount,inf_scroll=False):
    &#34;&#34;&#34;scroll along entries by moving along every tracked file, checking the dates, and only moving the relevant logmanagers

    parameters :
    int amount : the amount of times we&#39;ll attempt to scroll. goes to earlier entries if &lt;0, later otherwise
    bool inf_scroll : whether to ignore search timeout. used by UI live mode while going down the file.&#34;&#34;&#34;

    if amount == 0 :
        return

    if amount &lt; 0 :
        for i in range(-amount):
            self._scroll_up_once(inf_scroll)
    if amount &gt; 0 :
        for i in range(amount):
            self._scroll_down_once(inf_scroll)

    self.contents_changed = True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.search_date"><code class="name flex">
<span>def <span class="ident">search_date</span></span>(<span>self, date, refill=True)</span>
</code></dt>
<dd>
<div class="desc"><p>set the cursor for every LogmanagerWrapper to the first entry with a date &lt;= the date parameter.</p>
<p>parameters :
date|str date : a datetime or ISO date string representing the target date.
bool refill : refill every tracked deque</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_date(self,date,refill=True):
    &#34;&#34;&#34;set the cursor for every LogmanagerWrapper to the first entry with a date &lt;= the date parameter.

    parameters :
    date|str date : a datetime or ISO date string representing the target date.
    bool refill : refill every tracked deque&#34;&#34;&#34;

    for logman in self.log_mans:
        self.log_mans[logman].search_date(date)
        if refill :
            self.log_mans[logman].fill_queue(-1,self.filter)
    self.contents_changed = True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, timeout)</span>
</code></dt>
<dd>
<div class="desc"><p>set time search intervals for each logmanager, reset search flags</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timeout(self,timeout):
    &#34;&#34;&#34;set time search intervals for each logmanager, reset search flags&#34;&#34;&#34;
    self.search_timeout = timeout
    for logman in self.log_mans:
        self.log_mans[logman].search_timeout = timeout
    self.contents_changed = True</code></pre>
</details>
</dd>
<dt id="orea.logcontroller.LogController.update_filter"><code class="name flex">
<span>def <span class="ident">update_filter</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>create a new header filtering function using parameters currently stored in the controller, raises content flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_filter(self) -&gt; None:
    &#34;&#34;&#34;create a new header filtering function using parameters currently stored in the controller, raises content flag&#34;&#34;&#34;
    self.filter =  default_header_func(self.max_level,BoolOps.LESS_OR_EQUAL,self.topic_substring,
                                  self.message_substring,LogController.tribool[self.data_presence_idx])
    self.contents_changed = True


    for mankey in self.log_mans :


        logman = self.log_mans[mankey]
        logman.nothing_up_close = False #reset search timeouts
        logman.nothing_down_close = False
        if len(logman.queue)!=0 :
            logman._logmanager.byte_jump(logman.queue[-1].total_extension[0] + logman.queue[-1].total_extension[1]//2)
            logman.queue.clear()
            logman.fill_queue(-1,self.filter)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orea" href="index.html">orea</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orea.logcontroller.LogController" href="#orea.logcontroller.LogController">LogController</a></code></h4>
<ul class="">
<li><code><a title="orea.logcontroller.LogController.all_eof" href="#orea.logcontroller.LogController.all_eof">all_eof</a></code></li>
<li><code><a title="orea.logcontroller.LogController.collect_entries" href="#orea.logcontroller.LogController.collect_entries">collect_entries</a></code></li>
<li><code><a title="orea.logcontroller.LogController.contents_changed" href="#orea.logcontroller.LogController.contents_changed">contents_changed</a></code></li>
<li><code><a title="orea.logcontroller.LogController.est_total" href="#orea.logcontroller.LogController.est_total">est_total</a></code></li>
<li><code><a title="orea.logcontroller.LogController.filter" href="#orea.logcontroller.LogController.filter">filter</a></code></li>
<li><code><a title="orea.logcontroller.LogController.is_search_zone_limit" href="#orea.logcontroller.LogController.is_search_zone_limit">is_search_zone_limit</a></code></li>
<li><code><a title="orea.logcontroller.LogController.jump_first" href="#orea.logcontroller.LogController.jump_first">jump_first</a></code></li>
<li><code><a title="orea.logcontroller.LogController.jump_last" href="#orea.logcontroller.LogController.jump_last">jump_last</a></code></li>
<li><code><a title="orea.logcontroller.LogController.log_mans" href="#orea.logcontroller.LogController.log_mans">log_mans</a></code></li>
<li><code><a title="orea.logcontroller.LogController.mean_position" href="#orea.logcontroller.LogController.mean_position">mean_position</a></code></li>
<li><code><a title="orea.logcontroller.LogController.message_substring" href="#orea.logcontroller.LogController.message_substring">message_substring</a></code></li>
<li><code><a title="orea.logcontroller.LogController.scroll" href="#orea.logcontroller.LogController.scroll">scroll</a></code></li>
<li><code><a title="orea.logcontroller.LogController.search_date" href="#orea.logcontroller.LogController.search_date">search_date</a></code></li>
<li><code><a title="orea.logcontroller.LogController.search_timeout" href="#orea.logcontroller.LogController.search_timeout">search_timeout</a></code></li>
<li><code><a title="orea.logcontroller.LogController.set_timeout" href="#orea.logcontroller.LogController.set_timeout">set_timeout</a></code></li>
<li><code><a title="orea.logcontroller.LogController.sorted_entries" href="#orea.logcontroller.LogController.sorted_entries">sorted_entries</a></code></li>
<li><code><a title="orea.logcontroller.LogController.topic_substring" href="#orea.logcontroller.LogController.topic_substring">topic_substring</a></code></li>
<li><code><a title="orea.logcontroller.LogController.tribool" href="#orea.logcontroller.LogController.tribool">tribool</a></code></li>
<li><code><a title="orea.logcontroller.LogController.update_filter" href="#orea.logcontroller.LogController.update_filter">update_filter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>